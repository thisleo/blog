<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo使用说明</title>
    <url>/2021/07/16/Hexo%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/</url>
    <content><![CDATA[<h4 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h4><p>（1）在hexo博客目录下，进入Git Bash命令窗口中，输入以下命令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo new post "Hexo使用说明"</span><br></pre></td></tr></table></figure>

<p>（2）在博客目录下的/source/_posts/ 文件夹下，可以看到已经生成了标题为(在这里.md)的博客文件：<br>如图所示：</p>
<p><img src="http://img.dopobo.com/img/20210716132233.png" alt=""></p>
<p>（3）在（Hexo使用说明.md）文件中编辑自己的博客文章即可。<br>注意：Hexo 发布的文章是 Markdown 格式的文件， Markdown 基本语法的网址：<a href="http://www.markdown.cn/" target="_blank" rel="noopener">点这里前往</a></p>
<a id="more"></a>  


<h4 id="2、给文章添加分类和标签"><a href="#2、给文章添加分类和标签" class="headerlink" title="2、给文章添加分类和标签"></a>2、给文章添加分类和标签</h4><p>(1) 在（在这里.md）文件中设置tags和categories属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">title: 在这里</span><br><span class="line">date: 2018-08-02 11:41:10</span><br><span class="line">tags:</span><br><span class="line">- 博客           &#x2F;&#x2F;多个标签可以这样添加</span><br><span class="line">- hexo</span><br><span class="line">categories: web前端</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="http://img.dopobo.com/img/20210716132451.png" alt=""></p>
<h4 id="3、启动服务器，本地测试"><a href="#3、启动服务器，本地测试" class="headerlink" title="3、启动服务器，本地测试"></a>3、启动服务器，本地测试</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure>

<p>如图所示：</p>
<p><img src="http://img.dopobo.com/img/20210716132538.png" alt=""></p>
<h4 id="4、添加“阅读全文”按钮"><a href="#4、添加“阅读全文”按钮" class="headerlink" title="4、添加“阅读全文”按钮"></a>4、添加“阅读全文”按钮</h4><p>方法一：在文章任意你想添加的位置添加即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--more--&gt;</span><br></pre></td></tr></table></figure>

<p>|例如：<br>在这里.md里面的内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 在这里</span><br><span class="line">date: 2018-08-02 11:41:10</span><br><span class="line">tags:</span><br><span class="line">- 博客</span><br><span class="line">- hexo</span><br><span class="line">categories: web前端</span><br><span class="line">---</span><br><span class="line">javascript是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的javascript开发者，如果没有认真学习的话，也无法真正理解它们，这就是javascript的矛盾之处。由于javascript不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个javascript</span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line">后面的内容在首页不显示，只显示到&lt;!--more--&gt;这里</span><br></pre></td></tr></table></figure>

<p>在页面中显示的效果是：</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20210716131551.png" alt=""></p>
<p>方法二：设置首页文章以摘要形式显示，打开主题配置文件，找到auto_excerpt进行修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">auto_excerpt:</span><br><span class="line">  enable: true</span><br><span class="line">  length: 150</span><br></pre></td></tr></table></figure>

<p>其中length代表显示摘要的截取字符长度。<br>注：这两种方法，在博客首页显示的效果不一样，根据自己的需要，选择自己喜欢的方法</p>
<h4 id="5、在博文中添加图片"><a href="#5、在博文中添加图片" class="headerlink" title="5、在博文中添加图片"></a>5、在博文中添加图片</h4><p>方法一：<br>(1)在hexo目录下，安装插件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install hexo-asset-image --save</span><br></pre></td></tr></table></figure>

<p>(2)在hexo\source 目录下新建一个img文件夹，把图片放置在里面；<br>(3)在xxx.md文件中引用图片：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![header]( img&#x2F;header.jpg)</span><br></pre></td></tr></table></figure>

<p>方法二：<br>(1)在全局配置文件（hexo/_config.yml)中将post_asset_folder设置为true；<br>(2)创建文章（在创建的时候，会在hexo/source/_post目录下，生成一个XXX.md文件和一个XXX的文件夹）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;XXX&quot;</span><br></pre></td></tr></table></figure>

<p>(3)把XXX这个博文需要展示的图片放在XXX文件夹目录下；<br>(4)在XXX.md文件中引入图片的方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;% asset_img example.jpg This is an example image %&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6、发布到Github上"><a href="#6、发布到Github上" class="headerlink" title="6、发布到Github上"></a>6、发布到Github上</h4><p>（1）发表的文章在本地预览无误后，在 Git Bash 命令窗口执行以下命令：6、发布到Github上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>（2）在浏览器，访问自己的博客域名，即可看到刚 发布的文章</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>教程</tag>
      </tags>
  </entry>
  <entry>
    <title>Context上下文</title>
    <url>/2021/07/16/Context%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h1 id="1-Context概念"><a href="#1-Context概念" class="headerlink" title="1. Context概念"></a>1. Context概念</h1><p>在加载资源、启动一个新的Activity、获取系统服务、获取内部文件（夹）路径、创建View操作时等都需要Context的参与,<br>Context字面意思上下文，或者叫做场景，也就是用户与操作系统操作的一个过程，比如你打电话，场景包括电话程序对应的界面，以及隐藏在背后的数据</p>
<a id="more"></a>

<p>可以看到Activity、Service、Application都是Context的子类；</p>
<p>也就是说，Android系统的角度来理解：Context是一个场景，代表与操作系统的交互的一种过程。从程序的角度上来理解：Context是个抽象类，而Activity、Service、Application等都是该类的一个实现。</p>
<p>在仔细看一下上图：Activity、Service、Application都是继承自ContextWrapper，而ContextWrapper内部会包含一个base context，由这个base context去实现了绝大多数的方法。</p>
<h1 id="2-Context与ApplicationContext"><a href="#2-Context与ApplicationContext" class="headerlink" title="2. Context与ApplicationContext"></a>2. Context与ApplicationContext</h1><p>ApplicationContext并没有这个类, 应该叫做：Activity与Application在作为Context时的区别, 在需要Context的时候，如果是在Activity中，大多直接传个this，当在匿名内部类的时候，因为this不能用，需要写XXXActivity.this，很多人会偷懒，直接就来个getApplicationContext。<br>那么，XXXActivity.this和getApplicationContext的区别呢？</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20210716110624.png" alt=""></p>
<p>XXXActivity和getApplicationContext返回的肯定不是一个对象，一个是当前Activity的实例，一个是项目的Application的实例。既然区别这么明显，那么各自的使用场景肯定不同，乱使用可能会带来一些问题。</p>
<p>下面开始介绍在使用Context时，需要注意的问题。</p>
<h1 id="3-引用的保持"><a href="#3-引用的保持" class="headerlink" title="3. 引用的保持"></a>3. 引用的保持</h1><p>大家在编写一些类时，例如工具类，可能会编写成单例的方式，这些工具类大多需要去访问资源，也就说需要Context的参与。<br>在这样的情况下，就需要注意Context的引用问题。</p>
<p>例如以下的写法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mooc.shader.roundimageview;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> android.content.Context;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomManager</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> CustomManager sInstance;</span><br><span class="line">	<span class="keyword">private</span> Context mContext;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">CustomManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">this</span>.mContext = context;</span><br><span class="line">	&#125;</span><br><span class="line"> </span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> CustomManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> CustomManager(context);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//some methods </span></span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">someOtherMethodNeedContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于上述的单例，大家应该都不陌生（请别计较getInstance的效率问题），内部保持了一个Context的引用；<br>这么写是没有问题的，问题在于，这个Context哪来的我们不能确定，很大的可能性，你在某个Activity里面为了方便，直接传了个this;这样问题就来了，我们的这个类中的sInstance是一个static且强引用的，在其内部引用了一个Activity作为Context，也就是说，我们的这个Activity只要我们的项目活着，就没有办法进行内存回收。而我们的Activity的生命周期肯定没这么长，所以造成了内存泄漏。</p>
<p>那么，我们如何才能避免这样的问题呢？</p>
<p>有人会说，我们可以软引用，嗯，软引用，假如被回收了，你不怕NullPointException么。</p>
<p>把上述代码做下修改：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> CustomManager <span class="title">getInstance</span><span class="params">(Context context)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sInstance = <span class="keyword">new</span> CustomManager(context.getApplicationContext());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样，我们就解决了内存泄漏的问题，因为我们引用的是一个ApplicationContext，它的生命周期和我们的单例对象一致。<br>这样的话，可能有人会说，早说嘛，那我们以后都这么用不就行了，很遗憾的说，不行。上面我们已经说过，Context和Application Context的区别是很大的，也就是说，他们的应用场景（你也可以认为是能力）是不同的，并非所有Activity为Context的场景，Application Context都能搞定。</p>
<p>下面就开始介绍各种Context的应用场景。</p>
<h1 id="4-Context的应用场景"><a href="#4-Context的应用场景" class="headerlink" title="4. Context的应用场景"></a>4. Context的应用场景</h1><p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20210716110625.png" alt=""></p>
<p>大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：</p>
<p>数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task。一般情况不推荐。</p>
<p>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用。</p>
<p>数字3：在receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）</p>
<p>注：ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</p>
<p>好了，这里我们看下表格，重点看Activity和Application，可以看到，和UI相关的方法基本都不建议或者不可使用Application，并且，前三个操作基本不可能在Application中出现。实际上，只要把握住一点，凡是跟UI相关的，都应该使用Activity做为Context来处理；其他的一些操作，Service,Activity,Application等实例都可以，当然了，注意Context引用的持有，防止内存泄漏。</p>
<h1 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h1><p>好了，到此，Context的分析基本完成了，希望大家在以后的使用过程中，能够稍微考虑下，这里使用Activity合适吗？会不会造成内存泄漏？这里传入Application work吗？</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title>Moshi配合Retrofit在Kotlin中的使用</title>
    <url>/2020/08/05/Moshi%E9%85%8D%E5%90%88Retrofit%E5%9C%A8Kotlin%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>本文将展示如何在Android项目中使用Moshi（代替Gson的项目）配合Retrofit实现Json解析</p>
</blockquote>
<p>首先，你为什么要使用Moshi代替Gson呢？</p>
<p><a href="https://www.reddit.com/r/androiddev/comments/684flw/why_use_moshi_over_gson/" target="_blank" rel="noopener">https://www.reddit.com/r/androiddev/comments/684flw/why_use_moshi_over_gson/</a></p>
<h3 id="如何在Kotlin中使用Retrofit和Moshi？"><a href="#如何在Kotlin中使用Retrofit和Moshi？" class="headerlink" title="如何在Kotlin中使用Retrofit和Moshi？"></a>如何在Kotlin中使用Retrofit和Moshi？</h3><ol>
<li><p>添加依赖（Dependencies）</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">dependencies &#123;</span><br><span class="line">    implementation <span class="string">"com.squareup.retrofit2:converter-moshi:2.4.0"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果你仅仅在<code>Retrofit</code>中使用<code>Gson</code>，记得移除<code>Gson</code>的依赖</p>
<a id="more"></a></li>
<li><p>添加Moshi转换到<code>Retrofit</code>中</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">val</span> retrofit = Retrofit.Builder()</span><br><span class="line">        .baseUrl(<span class="string">"https://api.example.com"</span>)</span><br><span class="line">        .addConverterFactory(MoshiConverterFactory.create())</span><br><span class="line">        .build()</span><br></pre></td></tr></table></figure>

<p>注意：需要在<code>Retrofit</code>初始化的地方实现<code>Moshi</code>的转换工厂方法，用来代替<code>.addConverterFactory(MoshiConverterFactory.create())</code>。</p>
<p>不要忘记移除<code>GsonConverterFactory</code></p>
</li>
<li><p>更新你的网络数据</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">data</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span></span>(<span class="meta">@field:Json</span>(name = <span class="string">"id"</span>) <span class="keyword">val</span> id: String,</span><br><span class="line">                      <span class="meta">@field:Json</span>(name = <span class="string">"name"</span>) <span class="keyword">val</span> name: String)</span><br></pre></td></tr></table></figure>

<p>注意：Moshi中的<code>@Json</code>等效于Gson中的<code>@SerializedName</code>，不要忘记将<code>@SerializedName</code>替换为<code>@Json</code>。</p>
<p>为了防止因为混淆造成数据不可用，最好使用注释（即使变量的名称与JSON Key相同）</p>
<p><strong>本文只是简单介绍了Moshi，更多功能请前往<a href="https://github.com/square/moshi" target="_blank" rel="noopener">Moshi主页</a>查看</strong></p>
</li>
</ol>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Moshi</tag>
        <tag>Kotlin</tag>
        <tag>Retrofit</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo使用Fancybox问题记录</title>
    <url>/2020/07/22/Hexo%E4%BD%BF%E7%94%A8Fancybox%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<blockquote>
<p>搭建完成自己的Hexo博客后, 发现图片没有点击放大浏览的功能, 这怎么行!  看到<a href="https://github.com/fancyapps/fancybox" target="_blank" rel="noopener">Fancybox</a>还不错, 于是安装fancybox3, 但是安装完成使用后, 发现整个博客都变成空白的了, 看不到文章了, 经过问题排查发现了问题所在,特此记录下来</p>
</blockquote>
<h4 id="Fancybox安装"><a href="#Fancybox安装" class="headerlink" title="Fancybox安装"></a>Fancybox安装</h4><p>使用的主题是<code>next</code>, 其他主题没有用过, 原理应该一样</p>
<ul>
<li><p>切换到主题<code>lib</code>目录</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> theme/next/<span class="built_in">source</span>/lib</span><br></pre></td></tr></table></figure>
</li>
<li><p>下载插件</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox3 fancybox</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改主题配置文件`_config.yml</p>
<figure class="highlight zsh"><table><tr><td class="code"><pre><span class="line">fancybox: <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<a id="more"></a>

<p>  <strong>这里有坑↑</strong></p>
<p>  <img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200722133935.png" alt=""></p>
<p>  <img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200722133949.png" alt=""></p>
<h4 id="问题出现"><a href="#问题出现" class="headerlink" title="问题出现"></a>问题出现</h4><p>​        根据网上的博客看到只需要在<code>themes/next/source/lib/</code>中下载<a href="https://github.com/fancyapps/fancybox" target="_blank" rel="noopener">Fancybox</a> 然后在主题下的<code>_config.yml</code>中找到<code>fancybox</code>设置为<code>true</code>就可以了, 但是设置完成后发现,博客整个都是空白,并且网页有报错提示</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200722132018.png" alt=""></p>
<p>根据错误提示发现是<code>js</code>没有导入的问题</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200722132138.png" alt=""></p>
<p>网上搜索问题都只是介绍将<code>theme/next/_config.yml</code>下的<code>fancybox</code>设置为<code>true</code>, 却没有提示导入<code>js</code>文件, 纠结了好长时间</p>
<h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><p>通过查看<a href="https://github.com/theme-next/theme-next-fancybox3" target="_blank" rel="noopener">theme-next-fancybox3</a>的使用方法发现了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">vendors:</span><br><span class="line">  ...</span><br><span class="line">  fancybox: <span class="comment">//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js</span></span><br><span class="line">  fancybox_css: <span class="comment">//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css</span></span><br></pre></td></tr></table></figure>

<p>然后回头看<code>theme/next/_config.yml</code>中发现还有一段注释</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200722132746.png" alt=""></p>
<p>好像找到解决方法了, 试了下将这里注释掉,放开cdn的注释</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200722132646.png" alt=""></p>
<p>然后就OK了, 记录下帮助后人</p>
]]></content>
      <categories>
        <category>Blog</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>360加固 + 美团Walle多渠道自动化打包</title>
    <url>/2020/04/16/360%E5%8A%A0%E5%9B%BA-%E7%BE%8E%E5%9B%A2Walle%E5%A4%9A%E6%B8%A0%E9%81%93%E8%87%AA%E5%8A%A8%E5%8C%96%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p>使用美团<a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">walle</a>进行多渠道打包可以节省大量的时间, 但是使用中发现一个问题:</p>
<p><em>之前是使用walle打多渠道包, 然后将apk上传360进行加固; 后来发现加固之后的APP没有了渠道信息, 并且发现360加固完成后的自动重签名只有V1签名</em></p>
<p>因此需要我们自己手动重签名, 需要调整实现流程: <strong>加固——重签名——多渠道打包</strong></p>
<a id="more"></a>

<h4 id="我们希望实现gradle脚本实现自动化加固、签名和多渠道打包"><a href="#我们希望实现gradle脚本实现自动化加固、签名和多渠道打包" class="headerlink" title="我们希望实现gradle脚本实现自动化加固、签名和多渠道打包"></a>我们希望实现gradle脚本实现自动化加固、签名和多渠道打包</h4><p><em>目前可以使用<a href="https://github.com/yangchong211/YCWalleHelper" target="_blank" rel="noopener">瓦力多渠道打包的Python脚本</a>实现自动化打包, 但是使用的<code>python2.7</code>版本</em></p>
<p>另一种思路是使用gradle脚本实现:</p>
<p><strong>在此感谢原创作者：天子卿</strong></p>
<p><strong>附作者文章链接：<a href="https://juejin.im/post/5c825ac6f265da2db9129bd0" target="_blank" rel="noopener">https://juejin.im/post/5c825ac6f265da2db9129bd0</a></strong></p>
<p>通过作者文章完成此demo, 如有侵权,请联系删除</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200310093427.png" alt=""></p>
<blockquote>
<blockquote>
<blockquote>
<h3 id="首先是集成Walle"><a href="#首先是集成Walle" class="headerlink" title="首先是集成Walle"></a>首先是集成Walle</h3><p>这里只简单写下Gradle插件使用方式, 如有其他需求请查看主页<a href="https://github.com/Meituan-Dianping" target="_blank" rel="noopener">Meituan-Dianping</a>/<strong><a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">walle</a></strong></p>
<h4 id="配置build-gradle"><a href="#配置build-gradle" class="headerlink" title="配置build.gradle"></a>配置build.gradle</h4><p>在位于项目的根目录 <code>build.gradle</code> 文件中添加Walle Gradle插件的依赖， 如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">buildscript &#123;</span><br><span class="line"> dependencies &#123;</span><br><span class="line">     classpath <span class="string">'com.meituan.android.walle:plugin:1.1.6'</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>并在当前App的 <code>build.gradle</code> 文件中apply这个插件，并添加上用于读取渠道号的AAR</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">apply <span class="string">plugin:</span> <span class="string">'walle'</span></span><br><span class="line"></span><br><span class="line">dependencies &#123;</span><br><span class="line"> compile <span class="string">'com.meituan.android.walle:library:1.1.6'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="配置插件"><a href="#配置插件" class="headerlink" title="配置插件"></a>配置插件</h4><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">walle &#123;</span><br><span class="line"> <span class="comment">// 指定渠道包的输出路径</span></span><br><span class="line"> apkOutputFolder = <span class="keyword">new</span> File(<span class="string">"$&#123;project.buildDir&#125;/outputs/channels"</span>);</span><br><span class="line"> <span class="comment">// 定制渠道包的APK的文件名称</span></span><br><span class="line"> apkFileNameFormat = <span class="string">'$&#123;appName&#125;-$&#123;packageName&#125;-$&#123;channel&#125;-$&#123;buildType&#125;-v$&#123;versionName&#125;-$&#123;versionCode&#125;-$&#123;buildTime&#125;.apk'</span>;</span><br><span class="line"> <span class="comment">// 渠道配置文件</span></span><br><span class="line"> channelFile = <span class="keyword">new</span> File(<span class="string">"$&#123;project.getProjectDir()&#125;/channel"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何获取渠道信息"><a href="#如何获取渠道信息" class="headerlink" title="如何获取渠道信息"></a>如何获取渠道信息</h4><p>在需要渠道等信息时可以通过下面代码进行获取</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String channel = WalleChannelReader.getChannel(<span class="keyword">this</span>.getApplicationContext());</span><br></pre></td></tr></table></figure>


</blockquote>
</blockquote>
</blockquote>
<hr>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><h5 id="1-加固"><a href="#1-加固" class="headerlink" title="1. 加固"></a>1. 加固</h5><p>​    加固过程： 浏览了360加固官网，整个加固过程其实很简单，主要有以下的三个步骤：</p>
<ol>
<li><p>输入360加固平台的帐号、密码</p>
</li>
<li><p>将签名文件上传到加固平台</p>
</li>
<li><p>上传需要加固的apk文件进行加固</p>
<p>关键加固命令行代码如下：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 360加固</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apk 加固的原始apk File</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputPath 输出目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">def</span> reinforceApk(File apk,outputPath) &#123;</span><br><span class="line">    println <span class="string">"--- 360 reinforceApk start! ---"</span></span><br><span class="line">    println <span class="string">"reinforce apk:"</span> + apk</span><br><span class="line">    <span class="keyword">if</span>(apk == <span class="literal">null</span> || !apk.exists()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">'apk is not exists and cannot reinforce'</span>)</span><br><span class="line">        println <span class="string">"---360 reinforceApk throw exception and forced stop!---"</span></span><br><span class="line">    &#125;</span><br><span class="line">    exec &#123;</span><br><span class="line">        commandLine <span class="string">"&#123;命令执行符号&#125;"</span>, <span class="string">"-c"</span>, <span class="string">"java -jar $&#123;REINFORCE_JAR&#125; -login  $&#123;REINFORCE_NAME&#125; $&#123;REINFORCE_PASSWORD&#125;"</span></span><br><span class="line">        commandLine <span class="string">"&#123;命令执行符号&#125;"</span>, <span class="string">"-c"</span>, <span class="string">"java -jar $&#123;REINFORCE_JAR&#125; -showsign"</span></span><br><span class="line">        commandLine <span class="string">"&#123;命令执行符号&#125;"</span>, <span class="string">"-c"</span>, <span class="string">"java -jar $&#123;REINFORCE_JAR&#125; -jiagu $&#123;apk&#125; $&#123;outputPath&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    println <span class="string">"--- 360 reinforce end! ---"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明:</strong> 系统环境不同，<code>{命令执行符号}</code>也会不同（Linux系统：sh ；Mac系统：bash ；windows系统：powershell）;</p>
</li>
</ol>
<h5 id="2-重签名"><a href="#2-重签名" class="headerlink" title="2. 重签名"></a>2. 重签名</h5><p>​    加固完成后,对加固apk进行重签名;</p>
<p>​    使用AndroidSDK中的build-tools目录下, 使用压缩对齐工具和签名工具完成重签名, 步骤如下:</p>
<ol>
<li><p>对齐，对Apk文件进行存档对齐优化，确保所有的未压缩数据都从文件的开始位置以指定的对齐方式排列</p>
</li>
<li><p>签名，选择Signature V2   </p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">commandLine <span class="string">"&#123;命令执行符号&#125;"</span>,<span class="string">"-c"</span>, <span class="string">"&#123;zipalign工具的文件路径&#125; -v -p 4  &#123;已加固的apk文件路径&#125; &#123;对齐后输出的apk文件路径&#125;"</span></span><br><span class="line">commandLine <span class="string">"&#123;命令执行符号&#125;"</span>, <span class="string">"-c"</span>, <span class="string">"&#123;apksigner工具的文件路径&#125; sign --ks &#123;签名文件的位置&#125; --ks-key-alias &#123;alias别名&#125; --ks-pass pass:&#123;签名文件存储的密码&#125; --key-pass pass:&#123;alias密码&#125; --out &#123;签名后输出的apk文件&#125; &#123;对齐后输出的apk文件路径&#125;"</span></span><br></pre></td></tr></table></figure>



</li>
</ol>
<h5 id="3-多渠道打包"><a href="#3-多渠道打包" class="headerlink" title="3. 多渠道打包"></a>3. 多渠道打包</h5><p>​    签名完成后, 使用walle进行多渠道打包</p>
<p>​    平时使用walle多渠道打包，只需要在app/build.gradle下配置插件，指定渠道包的输出路径和渠道配置文件即    可，最后在Android studio的Terminal中输入./gradlew assembleReleaseChannels，任务执行完成后在指定的    输出路径下生成多个对应的渠道包。具体的流程和细节可参考<a href="https://github.com/Meituan-Dianping/walle" target="_blank" rel="noopener">官方介绍</a>。</p>
<p>​    这种多渠道打包方式是全自动化构建，很难去干涉到构建流程，不符合我们的需求   </p>
<ol>
<li><p>在app/build.gradle配置插件时，在官方介绍中并没有找到指定源APK输入路径的方式，估计打包插件默认使用的是app/build/outputs/apk/release下的apk文件，这样就没办法对不同文件路径下的已加固apk包进行多渠道打包。</p>
</li>
<li><p>打包任务设置在assembleRelease之后执行，这个执行依赖封装在插件内部，外部很难修改打包任务依赖于加固任务，在加固任务之后执行。     </p>
</li>
</ol>
<p>   除了上面的多渠道打包方式之后，walle还提供了另外一种多渠道打包方式，用命令行执行walle提供的walle-cli-all.jar执行打包操作，只需要一条打包命令即可完成打包。   </p>
   <figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">commandLine <span class="string">"sh"</span>, <span class="string">"-c"</span>, <span class="string">"java -jar &#123;walle-cli-all.jar文件路径&#125; batch -f &#123;渠道文件路径&#125; &#123;要加渠道的apk文件路径&#125; &#123;渠道包的输出路径&#125;"</span></span><br></pre></td></tr></table></figure>

<p>   walle-cli-all.jar文件下载地址：<a href="https://github.com/Meituan-Dianping/walle/tree/master/walle-cli" target="_blank" rel="noopener">官方:walle-cli-all.jar</a>, <a href="https://github.com/vclub/vclub.github.io/raw/master/walle-cli-all.jar" target="_blank" rel="noopener">其他开发提供的编译版本</a></p>
<p>   这里为什么会有两个版本呢! 因为发现了一个比较坑的地方官方的版本打完包会发现在系统9.0（P）下无法正常安装, 相关问题可以查看<a href="https://github.com/Meituan-Dianping/walle/issues/264" target="_blank" rel="noopener">Issue</a>, 当然你也可以自己拉取源码编译</p>
<hr>
<h3 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h3><p>首先，将加固和打包操作封装成自动化操作，利用gradle脚本构建加固任务。</p>
<p>为了代码解耦，我们不在app/build.gradle里面实现加固任务，而是重新建一个gradle文件來实现具体的加固和多渠道打包过程，在app/build.gradle只需要通过<code>apply from: &#39;×××.gradle&#39;</code>引用这个gradle文件即可，</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200310092933.png" alt=""></p>
<p>当需要修改加固的一些代码逻辑时，只需要在这个gradle文件里面修改。</p>
<p>引入工具包。根据自己的系统环境，在<a href="http://jiagu.360.cn/#/global/download" target="_blank" rel="noopener">加固助手网页</a>选择对应的加固助手工具，下载后将里面的jiagu文件夹拷贝到自己项目的根目录下;</p>
<p>在<a href="https://github.com/Meituan-Dianping/walle/tree/master/walle-cli" target="_blank" rel="noopener">walle-cli-jar下载链接</a>下载jar包到自己项目中。</p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200310093055.png" alt=""></p>
<p>确定加固任务的时机。加固任务时机应该在release包生成之后，那么加固任务应该依赖于assembleRelease这个任务，并且设置在这个任务之后执行。</p>
<p>接下来就是我们的基本流程了</p>
<pre><code>1. 找到release包, 一般在`app/build/outputs/apk/release/`路径下
2. 执行加固命令，将release包路径设置到命令中，并指定加固apk文件的输出路径
3. 找到已加固的apk文件，对已加固apk文件进行对齐、重签名。（360已加固的apk文件会在原有的release文件名后面加上&quot;_jiagu&quot;）
4. 找到重新签名的apk文件，执行多渠道打包命令。（重签名后的文件名是在原有文件名后面加上&quot;_sign&quot;）</code></pre><figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">task assembleReinforceRelease() &#123;</span><br><span class="line">    group <span class="string">'360reinforce'</span></span><br><span class="line">    dependsOn(<span class="string">"assembleRelease"</span>)</span><br><span class="line"></span><br><span class="line">    doLast &#123;</span><br><span class="line">        cleanFilesPath(CHANNEL_APKS_PATH)   <span class="comment">//清空上一次生成的渠道包</span></span><br><span class="line">        <span class="keyword">def</span> releaseApkFile = findApkFile(DEFAULT_APK_PATH, <span class="string">"-release"</span>)  <span class="comment">//遍历文件，寻找release包</span></span><br><span class="line">        println <span class="string">"--release--1-"</span> + releaseApkFile</span><br><span class="line">        <span class="keyword">if</span> (releaseApkFile != <span class="literal">null</span>) &#123;</span><br><span class="line">            reinforceApk(releaseApkFile, SOURCE_APK_PATH)   <span class="comment">//执行加固</span></span><br><span class="line">            <span class="keyword">def</span> reinforceApk = findApkFile(SOURCE_APK_PATH, <span class="string">"_jiagu"</span>)  <span class="comment">//寻找已加固的apk包</span></span><br><span class="line">            println <span class="string">"--jiagu--2-"</span> + reinforceApk</span><br><span class="line">            <span class="keyword">if</span>(reinforceApk != <span class="literal">null</span>) &#123;</span><br><span class="line">                zipAlignApk(reinforceApk) <span class="comment">// zip对齐</span></span><br><span class="line">                <span class="keyword">def</span> zipAlignApk = findApkFile(SOURCE_APK_PATH, <span class="string">"_zip"</span>)</span><br><span class="line">                <span class="keyword">if</span> (zipAlignApk != <span class="literal">null</span>) &#123;</span><br><span class="line">                    signApkV2(zipAlignApk)  <span class="comment">//使用V2重签名</span></span><br><span class="line">                    <span class="keyword">def</span> signatureApk = findApkFile(SOURCE_APK_PATH, <span class="string">"_sign"</span>)</span><br><span class="line">                    println <span class="string">"--sign--3-"</span> + signatureApk</span><br><span class="line">                    <span class="keyword">if</span>(signatureApk != <span class="literal">null</span>) &#123;</span><br><span class="line">                        buildChannelApks(signatureApk)  <span class="comment">//执行多渠道打包</span></span><br><span class="line">                        renameChannelApkFiles(CHANNEL_APKS_PATH) <span class="comment">//重命名渠道包</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码优化:</p>
<ol>
<li>流程中涉及360加固平台帐号密码等敏感信息，可以将这部分信息放到签名信息所在的文件（eg：keystore.properties）中统一管理，然后将这些信息加载到gradle文件中；</li>
<li>各种输入输出的文件路径定义为常量，便于修改和管理；</li>
</ol>
<p>加固方法:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 360加固</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apk 加固的原始apk File</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> outputPath 输出目录</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">def</span> reinforceApk(File apk, outputPath) &#123;</span><br><span class="line">    println <span class="string">"--- 360 reinforceApk start! ---"</span></span><br><span class="line">    println <span class="string">"reinforce apk:"</span> + apk</span><br><span class="line">    <span class="keyword">if</span> (apk == <span class="literal">null</span> || !apk.exists()) &#123;</span><br><span class="line">        println <span class="string">"---360 reinforceApk throw exception and forced stop!---"</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">'apk is not exists and cannot reinforce'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> file = <span class="keyword">new</span> File(outputPath)</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.mkdir()</span><br><span class="line">    &#125;</span><br><span class="line">    exec &#123;</span><br><span class="line">        commandLine getCommand(), <span class="string">"-c"</span>, <span class="string">"java -jar $&#123;REINFORCE_JAR&#125; -login  $&#123;REINFORCE_NAME&#125; $&#123;REINFORCE_PASSWORD&#125;"</span></span><br><span class="line">        commandLine getCommand(), <span class="string">"-c"</span>, <span class="string">"java -jar $&#123;REINFORCE_JAR&#125; -showsign"</span></span><br><span class="line">        commandLine getCommand(), <span class="string">"-c"</span>, <span class="string">"java -jar $&#123;REINFORCE_JAR&#125; -jiagu $&#123;apk&#125; $&#123;outputPath&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">    println <span class="string">"--- 360 reinforce end! ---"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>压缩对齐方法:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加固后的apk 对齐压缩</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apk 已加固apk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 返回对齐压缩后的apk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">def</span> zipAlignApk(File apk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (apk == <span class="literal">null</span> || !apk.exists()) &#123;</span><br><span class="line">        println <span class="string">"---zipalign reinforceApk throw exception and forced stop!---"</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">'apk is not exists and cannot reinforce'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> BUILD_TOOL_PATH = getAndroidSdkPath()</span><br><span class="line">    <span class="keyword">def</span> APK_NAME = getApkName() + <span class="string">"_jiagu_zip.apk"</span></span><br><span class="line">    <span class="keyword">def</span> file = <span class="keyword">new</span> File(<span class="string">"$&#123;SOURCE_APK_PATH&#125;/$&#123;APK_NAME&#125;"</span>)</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        file.delete()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    exec &#123;</span><br><span class="line">        commandLine getCommand(), <span class="string">"-c"</span>, <span class="string">"$&#123;BUILD_TOOL_PATH&#125;zipalign -v -p 4 $&#123;apk&#125; $&#123;SOURCE_APK_PATH&#125;/$&#123;APK_NAME&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>签名方法:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对apk签名</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> zipApk 压缩对齐后的apk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 签名后的apk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">def</span> signApkV2(File zipApk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (zipApk == <span class="literal">null</span> || !zipApk.exists()) &#123;</span><br><span class="line">        println <span class="string">"---sign zipApk throw exception and forced stop!---"</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">'apk is not exists and cannot reinforce'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> BUILD_TOOL_PATH = getAndroidSdkPath()</span><br><span class="line">    <span class="keyword">def</span> APK_NAME = <span class="string">"app-release_"</span> + getApkVersionName() + <span class="string">"_jiagu_zip_sign.apk"</span></span><br><span class="line">    <span class="keyword">def</span> file = <span class="keyword">new</span> File(<span class="string">"$&#123;SOURCE_APK_PATH&#125;/$&#123;APK_NAME&#125;"</span>)</span><br><span class="line">    <span class="keyword">if</span> (file.exists()) &#123;</span><br><span class="line">        file.delete()</span><br><span class="line">    &#125;</span><br><span class="line">    exec &#123;</span><br><span class="line">        commandLine getCommand(), <span class="string">"-c"</span>, <span class="string">"$&#123;BUILD_TOOL_PATH&#125;apksigner sign --ks $&#123;KEY_PATH&#125; --ks-key-alias $&#123;ALIAS&#125; --ks-pass pass:$&#123;KEY_PASSWORD&#125; --key-pass pass:$&#123;ALIAS_PASSWORD&#125; --out $&#123;SOURCE_APK_PATH&#125;/$&#123;APK_NAME&#125; $&#123;zipApk&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>添加渠道信息:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 对签名后的apk添加渠道信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> apk 已签名apk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> 添加渠道信息后的apk</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">def</span> buildChannelApks(File apk) &#123;</span><br><span class="line">    <span class="keyword">if</span> (apk == <span class="literal">null</span> || !apk.exists()) &#123;</span><br><span class="line">        println <span class="string">"---Channel build Apk throw exception and forced stop!---"</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">'apk is not exists and cannot reinforce'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> file = <span class="keyword">new</span> File(CHANNEL_APKS_PATH)</span><br><span class="line">    <span class="keyword">if</span> (!file.exists()) &#123;</span><br><span class="line">        file.mkdir()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">def</span> APK_NAME = getApkName() + <span class="string">"_jiagu_zip_sign.apk"</span></span><br><span class="line"></span><br><span class="line">    exec &#123;</span><br><span class="line">        <span class="comment">//java -jar walle-cli-all.jar batch -f /Users/Meituan/walle/app/channel  /Users/Meituan/walle/app/build/outputs/apk/app.apk</span></span><br><span class="line">        commandLine getCommand(), <span class="string">"-c"</span>, <span class="string">"java -jar $&#123;WALLE_JAR&#125; batch -f $&#123;WALLE_CHANNELS_CONFIG&#125; $&#123;SOURCE_APK_PATH&#125;/$&#123;APK_NAME&#125; $&#123;CHANNEL_APKS_PATH&#125;"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重命名apk:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 重命名apk</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> path 渠道apk目录路径</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">def</span> renameChannelApkFiles(path) &#123;</span><br><span class="line"><span class="comment">//    def APK_NAME = "app-release_" + getApkVersionName() + "_jiagu_zip_sign.apk"</span></span><br><span class="line">    <span class="keyword">def</span> regex = getApkName() + <span class="string">"_jiagu_zip_sign"</span></span><br><span class="line">    <span class="keyword">def</span> dir = <span class="keyword">new</span> File(path+<span class="string">"/"</span>)</span><br><span class="line">    dir.listFiles().each &#123;file -&gt;</span><br><span class="line">        <span class="keyword">if</span> (file.name =~ <span class="regexp">/$&#123;regex&#125;.*\.apk/</span>) &#123;</span><br><span class="line">            String newName = file.name</span><br><span class="line">            newName = newName.replaceAll(<span class="regexp">~/_jiagu/</span>, <span class="string">""</span>)</span><br><span class="line">            newName = newName.replaceAll(<span class="regexp">~/_zip/</span>, <span class="string">""</span>)</span><br><span class="line">            newName = newName.replaceAll(<span class="regexp">~/_sign/</span>, <span class="string">""</span>)</span><br><span class="line">            file.renameTo(<span class="keyword">new</span> File(file.getParent(), newName))</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>涉及到的各种常量，各种密钥名、路径都要根据自己的实际情况修改：</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*加载keystore.properties信息到该gradle文件中*/</span></span><br><span class="line"><span class="keyword">def</span> keystorePropertiesFile = rootProject.file(<span class="string">"keystore.properties"</span>)</span><br><span class="line"><span class="keyword">def</span> keystoreProperties = <span class="keyword">new</span> Properties()</span><br><span class="line">keystoreProperties.load(<span class="keyword">new</span> FileInputStream(keystorePropertiesFile))</span><br><span class="line"></span><br><span class="line">ext &#123;</span><br><span class="line">    <span class="comment">/*加固*/</span></span><br><span class="line">    REINFORCE_JAR = <span class="string">"$&#123;project.rootDir&#125;/jiagu/jiagu.jar"</span></span><br><span class="line">    REINFORCE_NAME = keystoreProperties[<span class="string">'360_NAME'</span>] <span class="comment">//360加固账号</span></span><br><span class="line">    REINFORCE_PASSWORD = keystoreProperties[<span class="string">'360_PASSWORD'</span>] <span class="comment">//360加固密码</span></span><br><span class="line">    KEY_PATH = keystoreProperties[<span class="string">'storeFile'</span>] <span class="comment">//密钥路径</span></span><br><span class="line">    KEY_PASSWORD = keystoreProperties[<span class="string">'storePassword'</span>] <span class="comment">//密钥密码</span></span><br><span class="line">    ALIAS = keystoreProperties[<span class="string">'keyAlias'</span>] <span class="comment">//密钥别名</span></span><br><span class="line">    ALIAS_PASSWORD = keystoreProperties[<span class="string">'keyPassword'</span>] <span class="comment">//别名密码</span></span><br><span class="line">    SOURCE_APK_PATH = <span class="string">"$&#123;project.buildDir&#125;/bakApk"</span>  <span class="comment">//源apk文件路径</span></span><br><span class="line">    DEFAULT_APK_PATH = <span class="string">"$&#123;project.buildDir&#125;/outputs/apk/release"</span> <span class="comment">//默认release文件路径</span></span><br><span class="line">    <span class="comment">/*多渠道打包*/</span></span><br><span class="line">    WALLE_JAR = <span class="string">"$&#123;project.rootDir&#125;/walle-cli-all.jar"</span></span><br><span class="line">    WALLE_CHANNELS_CONFIG = <span class="string">"$&#123;project.rootDir&#125;/app/channel"</span>  <span class="comment">//渠道配置文件</span></span><br><span class="line">    CHANNEL_APKS_PATH = <span class="string">"$&#123;project.buildDir&#125;/outputs/channels"</span>  <span class="comment">//渠道Apk输出路径</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200310093134.png" alt=""></p>
<p><a href="https://github.com/thisleo/reinforce_walle" target="_blank" rel="noopener">github地址</a></p>
<p><strong>再次感谢原创作者：天子卿</strong></p>
<p><strong>附作者文章链接：<a href="https://juejin.im/post/5c825ac6f265da2db9129bd0" target="_blank" rel="noopener">https://juejin.im/post/5c825ac6f265da2db9129bd0</a></strong></p>
<p><strong>在作者的启发下完成此demo, 如果对你有帮助请不要吝啬star</strong></p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Walle</tag>
        <tag>360加固</tag>
        <tag>Gradle</tag>
      </tags>
  </entry>
  <entry>
    <title>RecyclerView中的EditText被软键盘遮挡的解决办法</title>
    <url>/2020/04/16/RecyclerView%E4%B8%AD%E7%9A%84EditText%E8%A2%AB%E8%BD%AF%E9%94%AE%E7%9B%98%E9%81%AE%E6%8C%A1%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> </span><br><span class="line">getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(<span class="keyword">new</span> ViewTreeObserver.OnGlobalLayoutListener() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onGlobalLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mImgKeyboard.setImageResource(KeyboardUtils.isSoftShowing(ForumsPublishPostActivity.<span class="keyword">this</span>)</span><br><span class="line">                ? R.mipmap.jianpan_down_ico : R.mipmap.jianpan_ico);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 除了软键盘以外的可见区域</span></span><br><span class="line">        Rect rect = <span class="keyword">new</span> Rect();</span><br><span class="line">        getWindow().getDecorView().getWindowVisibleDisplayFrame(rect);</span><br><span class="line">        <span class="comment">// 计算出剩余高度：  除了状态栏高度、topBar高度、bottomBar高度、键盘高度的剩余高度</span></span><br><span class="line">        <span class="keyword">int</span> invisibleHeight = rect.bottom</span><br><span class="line">                - ViewUtils.getSystemBarHeight(ForumsPublishPostActivity.<span class="keyword">this</span>)</span><br><span class="line">                - ViewUtils.dp2px(ForumsPublishPostActivity.<span class="keyword">this</span>, <span class="number">44</span>)</span><br><span class="line">                - ViewUtils.dp2px(ForumsPublishPostActivity.<span class="keyword">this</span>, <span class="number">44</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 计算出所点击的图片描述的EditText距离RecyclerView顶部的距离</span></span><br><span class="line">        View etDescView = mRecyclerview.getLayoutManager().findViewByPosition(mAdapter.etFocusPosition);</span><br><span class="line">        <span class="keyword">if</span> (etDescView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> focusViewTop = etDescView.getTop();</span><br><span class="line">            <span class="keyword">int</span> itemHeight = etDescView.getHeight();</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> differ = focusViewTop + itemHeight - invisibleHeight;</span><br><span class="line">            <span class="keyword">if</span> (differ &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 让RecyclerView滚动差的那点距离</span></span><br><span class="line">                mRecyclerview.scrollBy(<span class="number">0</span>, differ);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>RecyclerView</tag>
        <tag>EditText</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下完全卸载干净Android Studio</title>
    <url>/2020/04/16/Mac%E4%B8%8B%E5%AE%8C%E5%85%A8%E5%8D%B8%E8%BD%BD%E5%B9%B2%E5%87%80Android-Studio/</url>
    <content><![CDATA[<p>第一步： 卸载Android Studio应用及相关配置</p>
<p>在终端中输入：</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -Rf /Applications/Android\ Studio.app</span><br><span class="line">rm -Rf ~/Library/Preferences/AndroidStudio*</span><br><span class="line">rm ~/Library/Preferences/com.google.android.studio.plist</span><br><span class="line">rm -Rf ~/Library/Application\ Support/AndroidStudio*</span><br><span class="line">rm -Rf ~/Library/Logs/AndroidStudio*</span><br><span class="line">rm -Rf ~/Library/Caches/AndroidStudio*</span><br></pre></td></tr></table></figure>

<p>第二步：删除所有Projects</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -Rf ~/AndroidStudioProjects</span><br></pre></td></tr></table></figure>

<p>第三步：删除gradle相关文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -Rf ~/.gradle</span><br></pre></td></tr></table></figure>

<p>第四步：卸载所有Android Virtual Devices(AVDs) and *.keystore. note:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -Rf ~/.android</span><br></pre></td></tr></table></figure>

<p>第五步：删除Android SDK tools，对应自己的sdk目录即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm -Rf ~/Library/Android*</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>卸载</tag>
        <tag>APP</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP 响应代码</title>
    <url>/2020/04/16/HTTP-%E5%93%8D%E5%BA%94%E4%BB%A3%E7%A0%81/</url>
    <content><![CDATA[<blockquote>
<blockquote>
<blockquote>
<p>HTTP 响应状态代码指示特定 <a href="https://developer.mozilla.org/zh-cn/HTTP" target="_blank" rel="noopener">HTTP</a> 请求是否已成功完成。响应分为五类：信息响应(<code>100</code>–<code>199</code>)，成功响应(<code>200</code>–<code>299</code>)，重定向(<code>300</code>–<code>399</code>)，客户端错误(<code>400</code>–<code>499</code>)和服务器错误 (<code>500</code>–<code>599</code>)。状态代码由 <a href="https://tools.ietf.org/html/rfc2616#section-10" target="_blank" rel="noopener">section 10 of RFC 2616</a>定义</p>
</blockquote>
</blockquote>
</blockquote>
<a id="more"></a>

<h3 id="信息响应"><a href="#信息响应" class="headerlink" title="信息响应"></a>信息响应</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/100" target="_blank" rel="noopener"><code>100 Continue</code></a></p>
<p>这个临时响应表明，迄今为止的所有内容都是可行的，客户端应该继续请求，如果已经完成，则忽略它。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/101" target="_blank" rel="noopener"><code>101 Switching Protocol</code></a></p>
<p>该代码是响应客户端的 <code>Upgrade</code> 标头发送的，并且指示服务器也正在切换的协议。</p>
<p><code>102 Processing</code> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/WebDAV" target="_blank" rel="noopener">WebDAV</a>)</p>
<p>此代码表示服务器已收到并正在处理该请求，但没有响应可用。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/103" target="_blank" rel="noopener"><code>103 Early Hints</code></a> </p>
<p>此状态代码主要用于与<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Link" target="_blank" rel="noopener"><code>Link</code></a> 链接头一起使用，以允许用户代理在服务器仍在准备响应时开始预加载资源。</p>
<hr>
<h3 id="成功响应"><a href="#成功响应" class="headerlink" title="成功响应"></a>成功响应</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/200" target="_blank" rel="noopener"><code>200 OK</code></a></p>
<p>请求成功。成功的含义取决于HTTP方法：</p>
<ul>
<li>GET：资源已被提取并在消息正文中传输。</li>
<li>HEAD：实体标头位于消息正文中。</li>
<li>POST：描述动作结果的资源在消息体中传输。</li>
<li>TRACE：消息正文包含服务器收到的请求消息</li>
</ul>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/201" target="_blank" rel="noopener"><code>201 Created</code></a></p>
<p>该请求已成功，并因此创建了一个新的资源。这通常是在POST请求，或是某些PUT请求之后返回的响应。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/202" target="_blank" rel="noopener"><code>202 Accepted</code></a></p>
<p>请求已经接收到，但还未响应，没有结果。意味着不会有一个异步的响应去表明当前请求的结果，预期另外的进程和服务去处理请求，或者批处理。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/203" target="_blank" rel="noopener"><code>203 Non-Authoritative Information</code></a></p>
<p>服务器已成功处理了请求，但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝。当前的信息可能是原始版本的子集或者超集。例如，包含资源的元数据可能导致原始服务器知道元信息的超集。使用此状态码不是必须的，而且只有在响应不使用此状态码便会返回200 OK的情况下才是合适的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/204" target="_blank" rel="noopener"><code>204 No Content</code></a></p>
<p>服务器成功处理了请求，但不需要返回任何实体内容，并且希望返回更新了的元信息。响应可能通过实体头部的形式，返回新的或更新后的元信息。如果存在这些头部信息，则应当与所请求的变量相呼应。如果客户端是浏览器的话，那么用户浏览器应保留发送了该请求的页面，而不产生任何文档视图上的变化，即使按照规范新的或更新后的元信息应当被应用到用户浏览器活动视图中的文档。由于204响应被禁止包含任何消息体，因此它始终以消息头后的第一个空行结尾。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/205" target="_blank" rel="noopener"><code>205 Reset Content</code></a></p>
<p>服务器成功处理了请求，且没有返回任何内容。但是与204响应不同，返回此状态码的响应要求请求者重置文档视图。该响应主要是被用于接受用户输入后，立即重置表单，以便用户能够轻松地开始另一次输入。与204响应一样，该响应也被禁止包含任何消息体，且以消息头后的第一个空行结束。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/206" target="_blank" rel="noopener"><code>206 Partial Content</code></a></p>
<p>服务器已经成功处理了部分 GET 请求。类似于 FlashGet 或者迅雷这类的 HTTP 下载工具都是使用此类响应实现断点续传或者将一个大文档分解为多个下载段同时下载。该请求必须包含 Range 头信息来指示客户端希望得到的内容范围，并且可能包含 If-Range 来作为请求条件。</p>
<p><code>207 Multi-Status</code> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/WebDAV" target="_blank" rel="noopener">WebDAV</a>)</p>
<p>由WebDAV(RFC 2518)扩展的状态码，代表之后的消息体将是一个XML消息，并且可能依照之前子请求数量的不同，包含一系列独立的响应代码。</p>
<p><code>208 Already Reported</code> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/WebDAV" target="_blank" rel="noopener">WebDAV</a>)</p>
<p>在 DAV 里面使用: propstat 响应元素以避免重复枚举多个绑定的内部成员到同一个集合。</p>
<p><code>226 IM Used</code> (<a href="https://tools.ietf.org/html/rfc3229" target="_blank" rel="noopener">HTTP Delta encoding</a>)</p>
<p>服务器已经完成了对资源的 GET 请求，并且响应是对当前实例应用的一个或多个实例操作结果的表示。</p>
<hr>
<h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/300" target="_blank" rel="noopener"><code>300 Multiple Choice</code></a></p>
<p>被请求的资源有一系列可供选择的回馈信息，每个都有自己特定的地址和浏览器驱动的商议信息。用户或浏览器能够自行选择一个首选的地址进行重定向。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/301" target="_blank" rel="noopener"><code>301 Moved Permanently</code></a></p>
<p>被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/302" target="_blank" rel="noopener"><code>302 Found</code></a></p>
<p>请求的资源现在临时从不同的 URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/303" target="_blank" rel="noopener"><code>303 See Other</code></a></p>
<p>对应当前请求的响应可以在另一个 URI 上被找到，而且客户端应当采用 GET 的方式访问那个资源。这个方法的存在主要是为了允许由脚本激活的POST请求输出重定向到一个新的资源。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/304" target="_blank" rel="noopener"><code>304 Not Modified</code></a></p>
<p>如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304 响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">305 Use Proxy</span><br></pre></td></tr></table></figure>

<p>被请求的资源必须通过指定的代理才能被访问。Location 域中将给出指定的代理所在的 URI 信息，接收者需要重复发送一个单独的请求，通过这个代理才能访问相应资源。只有原始服务器才能建立305响应。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">306 unused</span><br></pre></td></tr></table></figure>

<p>在最新版的规范中，306 状态码已经不再被使用。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/307" target="_blank" rel="noopener"><code>307 Temporary Redirect</code></a></p>
<p>请求的资源现在临时从不同的URI 响应请求。由于这样的重定向是临时的，客户端应当继续向原有地址发送以后的请求。只有在Cache-Control或Expires中进行了指定的情况下，这个响应才是可缓存的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/308" target="_blank" rel="noopener"><code>308 Permanent Redirect</code></a></p>
<p>这意味着资源现在永久位于由 <code>Location:</code> HTTP Response 标头指定的另一个 URI。 这与 <code>301 Moved Permanently HTTP</code> 响应代码具有相同的语义，但用户代理不能更改所使用的 HTTP 方法：如果在第一个请求中使用 <code>POST</code>，则必须在第二个请求中使用 <code>POST</code>。</p>
<hr>
<h3 id="客户端响应"><a href="#客户端响应" class="headerlink" title="客户端响应"></a>客户端响应</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/400" target="_blank" rel="noopener"><code>400 Bad Request</code></a></p>
<p>1、语义有误，当前请求无法被服务器理解。除非进行修改，否则客户端不应该重复提交这个请求。</p>
<p>2、请求参数有误。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/401" target="_blank" rel="noopener"><code>401 Unauthorized</code></a></p>
<p>当前请求需要用户验证。该响应必须包含一个适用于被请求资源的 WWW-Authenticate 信息头用以询问用户信息。客户端可以重复提交一个包含恰当的 Authorization 头信息的请求。如果当前请求已经包含了 Authorization 证书，那么401响应代表着服务器验证已经拒绝了那些证书。如果401响应包含了与前一个响应相同的身份验证询问，且浏览器已经至少尝试了一次验证，那么浏览器应当向用户展示响应中包含的实体信息，因为这个实体信息中可能包含了相关诊断信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">402 Payment Required</span><br></pre></td></tr></table></figure>

<p>此响应码保留以便将来使用，创造此响应码的最初目的是用于数字支付系统，然而现在并未使用。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/403" target="_blank" rel="noopener"><code>403 Forbidden</code></a></p>
<p>服务器已经理解请求，但是拒绝执行它。与 401 响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个 404 响应，假如它不希望让客户端获得任何信息。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/404" target="_blank" rel="noopener"><code>404 Not Found</code></a></p>
<p>请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/405" target="_blank" rel="noopener"><code>405 Method Not Allowed</code></a></p>
<p>请求行中指定的请求方法不能被用于请求相应的资源。该响应必须返回一个Allow 头信息用以表示出当前资源能够接受的请求方法的列表。 鉴于 PUT，DELETE 方法会对服务器上的资源进行写操作，因而绝大部分的网页服务器都不支持或者在默认配置下不允许上述请求方法，对于此类请求均会返回405错误。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/406" target="_blank" rel="noopener"><code>406 Not Acceptable</code></a></p>
<p>请求的资源的内容特性无法满足请求头中的条件，因而无法生成响应实体。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/407" target="_blank" rel="noopener"><code>407 Proxy Authentication Required</code></a></p>
<p>与401响应类似，只不过客户端必须在代理服务器上进行身份验证。代理服务器必须返回一个 Proxy-Authenticate 用以进行身份询问。客户端可以返回一个 Proxy-Authorization 信息头用以验证。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/408" target="_blank" rel="noopener"><code>408 Request Timeout</code></a></p>
<p>请求超时。客户端没有在服务器预备等待的时间内完成一个请求的发送。客户端可以随时再次提交这一请求而无需进行任何更改。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/409" target="_blank" rel="noopener"><code>409 Conflict</code></a></p>
<p>由于和被请求的资源的当前状态之间存在冲突，请求无法完成。这个代码只允许用在这样的情况下才能被使用：用户被认为能够解决冲突，并且会重新提交新的请求。该响应应当包含足够的信息以便用户发现冲突的源头。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/410" target="_blank" rel="noopener"><code>410 Gone</code></a></p>
<p>被请求的资源在服务器上已经不再可用，而且没有任何已知的转发地址。这样的状况应当被认为是永久性的。如果可能，拥有链接编辑功能的客户端应当在获得用户许可后删除所有指向这个地址的引用。如果服务器不知道或者无法确定这个状况是否是永久的，那么就应该使用 404 状态码。除非额外说明，否则这个响应是可缓存的。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/411" target="_blank" rel="noopener"><code>411 Length Required</code></a></p>
<p>服务器拒绝在没有定义 <code>Content-Length</code> 头的情况下接受请求。在添加了表明请求消息体长度的有效 <code>Content-Length</code> 头之后，客户端可以再次提交该请求。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/412" target="_blank" rel="noopener"><code>412 Precondition Failed</code></a></p>
<p>服务器在验证在请求的头字段中给出先决条件时，没能满足其中的一个或多个。这个状态码允许客户端在获取资源时在请求的元信息（请求头字段数据）中设置先决条件，以此避免该请求方法被应用到其希望的内容以外的资源上。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/413" target="_blank" rel="noopener"><code>413 Payload Too Large</code></a></p>
<p>服务器拒绝处理当前请求，因为该请求提交的实体数据大小超过了服务器愿意或者能够处理的范围。此种情况下，服务器可以关闭连接以免客户端继续发送此请求。如果这个状况是临时的，服务器应当返回一个 <code>Retry-After</code> 的响应头，以告知客户端可以在多少时间以后重新尝试。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/414" target="_blank" rel="noopener"><code>414 URI Too Long</code></a></p>
<p>请求的URI 长度超过了服务器能够解释的长度，因此服务器拒绝对该请求提供服务。这比较少见，通常的情况包括：本应使用POST方法的表单提交变成了GET方法，导致查询字符串（Query String）过长。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/415" target="_blank" rel="noopener"><code>415 Unsupported Media Type</code></a></p>
<p>对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式，因此请求被拒绝。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/416" target="_blank" rel="noopener"><code>416 Range Not Satisfiable</code></a></p>
<p>如果请求中包含了 Range 请求头，并且 Range 中指定的任何数据范围都与当前资源的可用范围不重合，同时请求中又没有定义 If-Range 请求头，那么服务器就应当返回416状态码。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/417" target="_blank" rel="noopener"><code>417 Expectation Failed</code></a></p>
<p>此响应代码意味着服务器无法满足 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Expect" target="_blank" rel="noopener"><code>Expect</code></a> 请求标头字段指示的期望值。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/418" target="_blank" rel="noopener"><code>418 I&#39;m a teapot</code></a></p>
<p>服务器拒绝尝试用 <code>“茶壶冲泡咖啡”</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">421 Misdirected Request</span><br></pre></td></tr></table></figure>

<p>该请求针对的是无法产生响应的服务器。 这可以由服务器发送，该服务器未配置为针对包含在请求 URI 中的方案和权限的组合产生响应。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/422" target="_blank" rel="noopener"><code>422 Unprocessable Entity</code></a> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/WebDAV" target="_blank" rel="noopener">WebDAV</a>)</p>
<p>请求格式良好，但由于语义错误而无法遵循。</p>
<p><code>423 Locked</code> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/WebDAV" target="_blank" rel="noopener">WebDAV</a>)</p>
<p>正在访问的资源被锁定。</p>
<p><code>424 Failed Dependency</code> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/WebDAV" target="_blank" rel="noopener">WebDAV</a>)</p>
<p>由于先前的请求失败，所以此次请求失败。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/425" target="_blank" rel="noopener"><code>425 Too Early</code></a></p>
<p>服务器不愿意冒着风险去处理可能重播的请求。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/426" target="_blank" rel="noopener"><code>426 Upgrade Required</code></a></p>
<p>服务器拒绝使用当前协议执行请求，但可能在客户机升级到其他协议后愿意这样做。 服务器在 426 响应中发送 <code>Upgrade</code> 头以指示所需的协议。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/428" target="_blank" rel="noopener"><code>428 Precondition Required</code></a></p>
<p>原始服务器要求该请求是有条件的。 旨在防止“丢失更新”问题，即客户端获取资源状态，修改该状态并将其返回服务器，同时第三方修改服务器上的状态，从而导致冲突。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/429" target="_blank" rel="noopener"><code>429 Too Many Requests</code></a></p>
<p>用户在给定的时间内发送了太多请求（“限制请求速率”）。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/431" target="_blank" rel="noopener"><code>431 Request Header Fields Too Large</code></a></p>
<p>服务器不愿意处理请求，因为它的 请求头字段太大（ Request Header Fields Too Large）。 请求可以在减小请求头字段的大小后重新提交。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/451" target="_blank" rel="noopener"><code>451 Unavailable For Legal Reasons</code></a></p>
<p>用户请求非法资源，例如：由政府审查的网页。</p>
<hr>
<h3 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/500" target="_blank" rel="noopener"><code>500 Internal Server Error</code></a></p>
<p>服务器遇到了不知道如何处理的情况。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/501" target="_blank" rel="noopener"><code>501 Not Implemented</code></a></p>
<p>此请求方法不被服务器支持且无法被处理。只有<code>GET</code>和<code>HEAD</code>是要求服务器支持的，它们必定不会返回此错误代码。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/502" target="_blank" rel="noopener"><code>502 Bad Gateway</code></a></p>
<p>此错误响应表明服务器作为网关需要得到一个处理这个请求的响应，但是得到一个错误的响应。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/503" target="_blank" rel="noopener"><code>503 Service Unavailable</code></a></p>
<p>服务器没有准备好处理请求。 常见原因是服务器因维护或重载而停机。 请注意，与此响应一起，应发送解释问题的用户友好页面。 这个响应应该用于临时条件和 <code>Retry-After</code>：如果可能的话，HTTP头应该包含恢复服务之前的估计时间。 网站管理员还必须注意与此响应一起发送的与缓存相关的标头，因为这些临时条件响应通常不应被缓存。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/504" target="_blank" rel="noopener"><code>504 Gateway Timeout</code></a></p>
<p>当服务器作为网关，不能及时得到响应时返回此错误代码。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/505" target="_blank" rel="noopener"><code>505 HTTP Version Not Supported</code></a></p>
<p>服务器不支持请求中所使用的HTTP协议版本。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/506" target="_blank" rel="noopener"><code>506 Variant Also Negotiates</code></a></p>
<p>服务器有一个内部配置错误：对请求的透明内容协商导致循环引用。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/507" target="_blank" rel="noopener"><code>507 Insufficient Storage</code></a></p>
<p>服务器有内部配置错误：所选的变体资源被配置为参与透明内容协商本身，因此不是协商过程中的适当端点。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/508" target="_blank" rel="noopener"><code>508 Loop Detected</code></a> (<a href="https://developer.mozilla.org/en-US/docs/Glossary/WebDAV" target="_blank" rel="noopener">WebDAV</a>)</p>
<p>服务器在处理请求时检测到无限循环。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/510" target="_blank" rel="noopener"><code>510 Not Extended</code></a></p>
<p>客户端需要对请求进一步扩展，服务器才能实现它。服务器会回复客户端发出扩展请求所需的所有信息。</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/511" target="_blank" rel="noopener"><code>511 Network Authentication Required</code></a></p>
<p>511 状态码指示客户端需要进行身份验证才能获得网络访问权限。</p>
]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title>Android 解决 API &#39;variantOutput.getPackageApplication()&#39; is obsolete</title>
    <url>/2020/04/16/Android-%E8%A7%A3%E5%86%B3-API-variantOutput-getPackageApplication-is-obsolete/</url>
    <content><![CDATA[<p><strong>Gradle升级3.2.1以后打包提示一个警告:</strong></p>
<p><img src="https://gitee.com/cdyiwhy/imgbed/raw/master/img/20200720090126.png" alt=""></p>
<p>根据字面意思<code>variantOutput.getPackageApplication()</code> 这个方法废弃了, 但是项目中全局搜索这个关键词没有找到调用这个方法, 最后是因为下面这段代码:</p>
<a id="more"></a>

<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.each &#123; output -&gt;</span><br><span class="line">                    <span class="keyword">def</span> outputFile = output.outputFile</span><br><span class="line">                    <span class="keyword">if</span> (outputFile != <span class="literal">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</span><br><span class="line">                        <span class="keyword">def</span> fileName = <span class="string">"app-$&#123;defaultConfig.versionName&#125;-release.apk"</span></span><br><span class="line">                        outputFileName = fileName</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>这是写在 build.gradle 中用于自定义生成 apk 名的一段代码.</p>
<p>经过排查这个问题是由 <code>output.outputFile</code> 引起的，说明在调用 <code>getOutputFile()</code> 这个方法时，方法里调用了 <code>getPackageApplication()</code> 这个方法，既然是暗里调用，那只能去看源码了</p>
<p>首先进入 gradle-3.3.0-sources.jar ，找到了 <code>getApplicationVariants()</code> 方法所在</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> DomainObjectSet&lt;ApplicationVariant&gt; getApplicationVariants() &#123;</span><br><span class="line">        <span class="keyword">return</span> applicationVariantList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样我们就知道了 <code>applicationVariants.all { variant -&gt;</code> 中的 variant 是 <code>ApplicationVariant</code> ，但是 <code>ApplicationVariant</code> 是一个接口</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.android.build.gradle.api;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.android.build.gradle.internal.api.TestedVariant;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A Build variant and all its public data.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationVariant</span> <span class="keyword">extends</span> <span class="title">ApkVariant</span>, <span class="title">TestedVariant</span> &#123;</span>&#125;</span><br></pre></td></tr></table></figure>

<p>继续寻找具体类，然后找到了 <code>ApplicationVariantImpl</code> ，路径</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the variant outputs. There should always be at least one output.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> a non-null list of variants.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line">DomainObjectCollection&lt;BaseVariantOutput&gt; getOutputs();</span><br></pre></td></tr></table></figure>

<p>output 是 <code>BaseVariantOutput</code> ，会发现 <code>BaseVariantOutput</code> 又是一个接口，面向接口编程的坏处就是，别人看的时候要一层层剥离，才能找到内心，最终发现具体类是 <code>ApkVariantOutputImpl</code></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> File getOutputFile() &#123;</span><br><span class="line">    PackageAndroidArtifact packageAndroidArtifact = getPackageApplication();</span><br><span class="line">    <span class="keyword">if</span> (packageAndroidArtifact != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> File(</span><br><span class="line">            packageAndroidArtifact.getOutputDirectory(), apkData.getOutputFileName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.getOutputFile();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>终于找到问题源头了，在 <code>getOutputFile()</code> 方法里头调用了 <code>getPackageApplication()</code> 方法，但这是 gradle 的源码，我们没法修改，所有只能不要再使用 <code>getOutputFile()</code> 方法了</p>
<p>那如果要更改输出路径的时候该怎么办呢？不是建议让我们用 <code>getPackageApplicationProvider()</code> 方法么，我们来看看这个方法得到的是啥？</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns the packaging task</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;Prefer this to &#123;<span class="doctag">@link</span> #getPackageApplication()&#125; as it triggers eager configuration of the</span></span><br><span class="line"><span class="comment"> * task.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Nullable</span></span><br><span class="line">TaskProvider&lt;PackageAndroidArtifact&gt; getPackageApplicationProvider();</span><br></pre></td></tr></table></figure>

<p>一个任务提供者，实际起作用的是 <code>PackageAndroidArtifact</code> ，所有直接看其源码，我们只取所需:</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line"><span class="keyword">protected</span> File outputDirectory;</span><br></pre></td></tr></table></figure>

<p><strong>现在我要把 apk 输出到项目根目录下，就可以这样写了</strong></p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">applicationVariants.all &#123; variant -&gt;</span><br><span class="line">    variant.outputs.each &#123; output -&gt;</span><br><span class="line">        variant.packageApplicationProvider.get().outputDirectory = <span class="keyword">new</span> File(project.rootDir.absolutePath + <span class="string">"/apk"</span>)</span><br><span class="line">        <span class="keyword">def</span> fileName = <span class="string">"app-v$&#123;defaultConfig.versionName&#125;-release.apk"</span></span><br><span class="line">        output.outputFileName = fileName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>bug</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown基本语法</title>
    <url>/2020/03/25/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<p>Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p>
<p>相比WYSIWYG编辑器</p>
<a id="more"></a>

<p><strong>优点：</strong><br> 1、因为是纯文本，所以只要支持Markdown的地方都能获得一样的编辑效果，可以让作者摆脱排版的困扰，专心写作。<br> 2、操作简单。比如:WYSIWYG编辑时标记个标题，先选中内容，再点击导航栏的标题按钮，选择几级标题。要三个步骤。而Markdown只需要在标题内容前加#即可</p>
<p><strong>缺点：</strong><br> 1、需要记一些语法（当然，是很简单。五分钟学会）。<br> 2、有些平台不支持Markdown编辑模式。</p>
<p>还好，简书是支持Markdown编辑模式的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line">开启方式：设置-&gt;默认编辑器-&gt;Markdown编辑器</span><br></pre></td></tr></table></figure>

<h1 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h1><p>在想要设置为标题的文字前面加#来表示<br> 一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。</p>
<p>注：标准语法一般在#后跟个空格再写文字，貌似简书不加空格也行。</p>
<p>示例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 这是一级标题</span></span><br><span class="line"><span class="comment">## 这是二级标题</span></span><br><span class="line"><span class="comment">### 这是三级标题</span></span><br><span class="line"><span class="comment">#### 这是四级标题</span></span><br><span class="line"><span class="comment">##### 这是五级标题</span></span><br><span class="line"><span class="comment">###### 这是六级标题</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<h1 id="这是一级标题"><a href="#这是一级标题" class="headerlink" title="这是一级标题"></a>这是一级标题</h1><h2 id="这是二级标题"><a href="#这是二级标题" class="headerlink" title="这是二级标题"></a>这是二级标题</h2><h3 id="这是三级标题"><a href="#这是三级标题" class="headerlink" title="这是三级标题"></a>这是三级标题</h3><h4 id="这是四级标题"><a href="#这是四级标题" class="headerlink" title="这是四级标题"></a>这是四级标题</h4><h5 id="这是五级标题"><a href="#这是五级标题" class="headerlink" title="这是五级标题"></a>这是五级标题</h5><h6 id="这是六级标题"><a href="#这是六级标题" class="headerlink" title="这是六级标题"></a>这是六级标题</h6><hr>
<h1 id="二、字体"><a href="#二、字体" class="headerlink" title="二、字体"></a>二、字体</h1><ul>
<li><h5 id="加粗"><a href="#加粗" class="headerlink" title="加粗"></a>加粗</h5></li>
</ul>
<p>要加粗的文字左右分别用两个*号包起来</p>
<ul>
<li><h5 id="斜体"><a href="#斜体" class="headerlink" title="斜体"></a>斜体</h5></li>
</ul>
<p>要倾斜的文字左右分别用一个*号包起来</p>
<ul>
<li><h5 id="斜体加粗"><a href="#斜体加粗" class="headerlink" title="斜体加粗"></a>斜体加粗</h5></li>
</ul>
<p>要倾斜和加粗的文字左右分别用三个*号包起来</p>
<ul>
<li><h5 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h5></li>
</ul>
<p>要加删除线的文字左右分别用两个~~号包起来</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*&#96;</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><strong>这是加粗的文字</strong><br> <em>这是倾斜的文字</em><br> <strong><em>这是斜体加粗的文字\</em></strong><br> <del>这是加删除线的文字</del></p>
<hr>
<h1 id="三、引用"><a href="#三、引用" class="headerlink" title="三、引用"></a>三、引用</h1><p>在引用的文字前加&gt;即可。引用也可以嵌套，如加两个&gt;&gt;三个&gt;&gt;&gt;<br> n个…<br> 貌似可以一直加下去，但没神马卵用</p>
<p>示例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">&gt;这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>这是引用的内容</span><br><span class="line"><span class="meta">&gt;&gt;</span>&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<p>这是引用的内容</p>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>这是引用的内容</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<h1 id="四、分割线"><a href="#四、分割线" class="headerlink" title="四、分割线"></a>四、分割线</h1><p>三个或者三个以上的 - 或者 * 都可以。</p>
<p>示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>

<p>效果如下：<br> 可以看到，显示效果是一样的。</p>
<hr>
<hr>
<hr>
<hr>
<h1 id="五、图片"><a href="#五、图片" class="headerlink" title="五、图片"></a>五、图片</h1><p>语法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 <span class="string">''</span>图片title<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">图片alt就是显示在图片下面的文字，相当于对图片内容的解释。</span><br><span class="line">图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">![blockchain](https:<span class="comment">//ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</span></span><br><span class="line">u=<span class="number">702257389</span>,<span class="number">1274025419</span>&amp;fm=<span class="number">27</span>&amp;gp=<span class="number">0.</span>jpg <span class="string">"区块链"</span>)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>![blockchain](<a href="https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/" target="_blank" rel="noopener">https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/</a><br>u=702257389,1274025419&amp;fm=27&amp;gp=0.jpg “区块链”)</p>
<p><strong>上传本地图片直接点击导航栏的图片标志，选择图片即可</strong></p>
<p>markdown格式追求的是简单、多平台统一。那么图片的存储就是一个问题，需要用图床，提供统一的外链，这样就不用在不同的平台去处理图片的问题了。才能做到书写一次，各处使用。<br> 关于图床的选择我写了一篇文章，对网上存在的各种方法做了总结，需要的朋友可以看看。<a href="https://www.jianshu.com/p/ea1eb11db63f" target="_blank" rel="noopener">markdown图床</a></p>
<h1 id="六、超链接"><a href="#六、超链接" class="headerlink" title="六、超链接"></a>六、超链接</h1><p>语法：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">超链接名</span>](超链接地址 <span class="string">"超链接title"</span>)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">简书</span>](http:<span class="comment">//jianshu.com)</span></span><br><span class="line">[<span class="meta">百度</span>](http:<span class="comment">//baidu.com)</span></span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p><a href="https://www.jianshu.com/u/1f5ac0cf6a8b" target="_blank" rel="noopener">简书</a><br> <a href="https://links.jianshu.com/go?to=http%3A%2F%2Fbaidu.com" target="_blank" rel="noopener">百度</a></p>
<p>注：Markdown本身语法不支持链接在新页面中打开，貌似简书做了处理，是可以的。别的平台可能就不行了，如果想要在新页面中打开的话可以用html语言的a标签代替。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"超链接地址"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>超链接名<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">示例</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"https://www.jianshu.com/u/1f5ac0cf6a8b"</span> <span class="attr">target</span>=<span class="string">"_blank"</span>&gt;</span>简书<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="七、列表"><a href="#七、列表" class="headerlink" title="七、列表"></a>七、列表</h1><h5 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h5><p>语法：<br> 无序列表用 - + * 任何一种都可以</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ul>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ul>
<h5 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h5><p>语法：<br> 数字加点</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<h5 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h5><p><strong>上一级和下一级之间敲三个空格即可</strong></p>
<ul>
<li>一级无序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级无序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ul>
<ol>
<li>一级有序列表内容<ul>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
<li>二级无序列表内容</li>
</ul>
</li>
<li>一级有序列表内容<ol>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
<li>二级有序列表内容</li>
</ol>
</li>
</ol>
<hr>
<h1 id="八、表格"><a href="#八、表格" class="headerlink" title="八、表格"></a>八、表格</h1><p>语法：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">表头<span class="params">|表头|</span>表头</span><br><span class="line">---<span class="params">|:--:|</span>---<span class="symbol">:</span></span><br><span class="line">内容<span class="params">|内容|</span>内容</span><br><span class="line">内容<span class="params">|内容|</span>内容</span><br><span class="line"></span><br><span class="line">第二行分割表头和内容。</span><br><span class="line">- 有一个就行，为了对齐，多加了几个</span><br><span class="line">文字默认居左</span><br><span class="line">-两边加：表示文字居中</span><br><span class="line">-右边加：表示文字居右</span><br><span class="line">注：原生的语法两边都要用 <span class="params">| 包起来。此处省略</span></span><br></pre></td></tr></table></figure>

<p>示例：</p>
<figure class="highlight ruby"><table><tr><td class="code"><pre><span class="line">姓名<span class="params">|技能|</span>排行</span><br><span class="line">--<span class="params">|:--:|</span>--<span class="symbol">:</span></span><br><span class="line">刘备<span class="params">|哭|</span>大哥</span><br><span class="line">关羽<span class="params">|打|</span>二哥</span><br><span class="line">张飞<span class="params">|骂|</span>三弟</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<table>
<thead>
<tr>
<th>姓名</th>
<th align="center">技能</th>
<th align="right">排行</th>
</tr>
</thead>
<tbody><tr>
<td>刘备</td>
<td align="center">哭</td>
<td align="right">大哥</td>
</tr>
<tr>
<td>关羽</td>
<td align="center">打</td>
<td align="right">二哥</td>
</tr>
<tr>
<td>张飞</td>
<td align="center">骂</td>
<td align="right">三弟</td>
</tr>
</tbody></table>
<h1 id="九、代码"><a href="#九、代码" class="headerlink" title="九、代码"></a>九、代码</h1><p>语法：<br> 单行代码：代码之间分别用一个反引号包起来</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`代码内容`</span></span><br></pre></td></tr></table></figure>

<p>代码块：代码之间分别用三个反引号包起来，且两边的反引号单独占一行</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">(<span class="string">``</span><span class="string">`)</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">  代码...</span></span><br><span class="line"><span class="string">(`</span><span class="string">``</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可。</p>
</blockquote>
<p>示例：</p>
<p>单行代码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="string">`create database hero;`</span></span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">(```)</span><br><span class="line">    function <span class="function"><span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">         echo <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">fun</span><span class="params">()</span></span>;</span><br><span class="line">(```)</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<p>单行代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create database hero;</span><br></pre></td></tr></table></figure>

<p>代码块</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">echo</span> <span class="string">"这是一句非常牛逼的代码"</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun();</span><br></pre></td></tr></table></figure>

<h1 id="十、流程图"><a href="#十、流程图" class="headerlink" title="十、流程图"></a>十、流程图</h1><figure class="highlight php"><table><tr><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始</span><br><span class="line">op=&gt;operation: My Operation</span><br><span class="line">cond=&gt;condition: Yes <span class="keyword">or</span> No?</span><br><span class="line">e=&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;```</span><br></pre></td></tr></table></figure>

<p>效果如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始</span><br><span class="line">op&#x3D;&gt;operation: My Operation</span><br><span class="line">cond&#x3D;&gt;condition: Yes or No?</span><br><span class="line">e&#x3D;&gt;end</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;e</span><br><span class="line">cond(no)-&gt;op</span><br><span class="line">&amp;</span><br></pre></td></tr></table></figure>
<pre><code></code></pre>]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/24/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p><img src="http://img.dopobo.com/img/20200324142033.png" alt="测试灯箱"></p>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
]]></content>
  </entry>
</search>
